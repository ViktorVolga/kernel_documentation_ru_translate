RS485 связь через последовательное соединение

Введение

    EIA-485, так же известный как TIA/EIA-485 или RS-485 стандарт определяющий электрические
    характеристики драйверов и приемников для использования в сбаласированной цифровой системе
    со множеством точек. Этот стандарт широко используется в промышленной автоматике потому что
    может эфективно использоваться на больших расстояниях и в среде в которой много электрических
    шумов.

Соображения связанные с аппаратным обеспечением

    Некоторые процессоры/uart порты (такие как Atmel AT91 или 16C950 UART) содержат встроенные
    полудуплексные режимы совместимости, способные автоматически контролировать линию передачи
    переключением RTS или DTR сигналов. Что может быть использовано для контроля внешнего 
    полудуплексного аппаратного обеспечения такого как RS485 приемопередатчик или любое RS232
    полудуплексное устройство как некоторые модемы. Для таких микроконтроллеров драйверы linux
    должны иметь возможность работать в обоих режимах и правильный йоктл (см. далее) должен быть
    способен на пользовательском уровне переключаться из одного режима в другой и наоборот.

Структуры данных уже доступные в Ядре.

    Ядро Линукс предоставляет  struct serial_rs485 для управления коммуникацией по RS485. эфективно
    структуры данных используются для установки и и конфигурации параметров RS485 в платформенных
    данных  и в йоктлах.

    Дерево устройств может также во время загрузки поставлять параметры RS485. Серийное ядро
    заполняет struct serial_rs485 данными предоставленными деревом устройств когда драйвер вызывает
    uart_get_rs485_mode().

    Любой драйвер для устройств совместимых с RS232 и RS485 должен осуществлять вызов rs485_config
    и предоставлять rs485_supported в структуре uart_port. Серийное ядро вызывает rs485_config
    чтобы выполнить специфичную для устройства часть работы в ответ на TIOCSRS485 ioctl. Вызов
    rs485_config сохраняет указатель на пустую структуру rs485_config. В пользовательское 
    пространстве структура serial_rs485 предоставляется очищенной до вызова rs485_config используя
    rs485_supported которая указывает что функции RS485 драйвер поддерживает для структуры 
    uart_port. TIOCGRS485 ioctl может быть использован для чтения структуры serial_rs485 для
    текущей конфигурации 

struct serial_rs485 {
    __u32 flags;
#define SER_RS485_ENABLED               (1 << 0);
#define SER_RS485_RTS_ON_SEND           (1 << 1);
#define SER_RS485_RTS_AFTER_SEND        (1 << 2);
#define SER_RS485_RX_DURING_TX          (1 << 4);
#define SER_RS485_TERMINATE_BUS         (1 << 5);
#define SER_RS485_ADDRB                 (1 << 6);
#define SER_RS485_ADDR_RECV             (1 << 7);
#define SER_RS485_ADDR_DEST             (1 << 8);
    __u32 delay_rts_before_send;
    __u32 delay_rts_after_send;
    union {
        __u32 padding[5];
        struct {
            __u8 addr_recv;
            __u8 addr_dest;
            __u8 padding0[2];
            __u32 padding1[4];
        };
    };
};

flags - содержит флаги поддерживаемых функций.

delay_rts_before_send - задержка перед отправкой в милисекундах

delay_rts_after_send - задержка после отправки в милисекундах

{unnamed_union} - анонимно (в документации на ядро так и написано чтобы это ни значило)

padding - Устарело, вместо этого используйте padding0 и padding1. Не используйте с addr_recv и addr_dest
    (из-за перекрытия).

{unnamed_struct} - анонимно (в документации на ядро так и написано чтобы это ни значило)






